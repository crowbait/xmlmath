#!/bin/bash
set -e

source "ext_help"

# Print help if no arguments are passed
if [[ $# -eq 0 ]]; then
  print_help
  exit 0
fi

# --- Default values ---
FILE=""
INPLACE="false"
INTEGER_MODE="false"
MIN_VALUE=""
MAX_VALUE=""
REGEX_MODE="false"
WITHIN_TAG=""
WITHIN_TAG_ADDITIONAL=""
VERBOSE="false"
PROGRESS="false"

# --- Parse positional args ---
TARGET_MODE="$1"
OP_MODE="$2"
MODIFIER="$3"
shift 3

# Collect options
while [[ "$1" == --* || "$1" == -* ]]; do
  case "$1" in
    --file|-f)
      FILE="$2"
      shift 2
      ;;
    --inplace|-p)
      INPLACE="true"
      shift
      ;;
    --int|-i)
      INTEGER_MODE="true"
      shift
      ;;
    --min)
      MIN_VALUE="$2"
      shift 2
      ;;
    --max)
      MAX_VALUE="$2"
      shift 2
      ;;
    --regex|-r)
      REGEX_MODE="true"
      shift
      ;;
    --within|-w)
      WITHIN_TAG="$2"
      shift 2
      ;;
    --within-additional|--wa)
      WITHIN_TAG_ADDITIONAL="$2"
      shift 2
      ;;
    --verbose|-v)
      VERBOSE="true"
      shift
      ;;
    --progress)
      PROGRESS="true"
      shift 1
      ;;
    help)
      print_help
      exit 0
      ;;
    *)
      echo "❌ Unknown option: $1"
      echo ""
      print_help
      exit 1
      ;;
  esac
done

TARGETS=("$@")

# Validate modes
if [[ "$TARGET_MODE" != "attr" && "$TARGET_MODE" != "value" ]]; then
  print_help
  echo ""
  echo "❌ Invalid target mode: $TARGET_MODE"
  exit 1
fi

if [[ "$OP_MODE" != "add" && "$OP_MODE" != "a" &&
      "$OP_MODE" != "subtract" && "$OP_MODE" != "s" &&
      "$OP_MODE" != "multiply" && "$OP_MODE" != "m" &&
      "$OP_MODE" != "divide" && "$OP_MODE" != "d" &&
      "$OP_MODE" != "set" && "$OP_MODE" != "s" ]]; then
  print_help
  echo ""
  echo "❌ Invalid operation mode: $OP_MODE"
  exit 1
fi

if [[ "$OP_MODE" != "format" && "$OP_MODE" != "f" && ! "$MODIFIER" =~ ^-?[0-9]+(\.[0-9]+)?$ ]]; then
  print_help
  echo ""
  echo "❌ Invalid modifier: $MODIFIER"
  exit 1
fi

# Check if --inplace; requires --file
if [[ "$INPLACE" == "true" && -z "$FILE" ]]; then
  print_help
  echo ""
  echo "❌ --inplace requires --file"
  exit 1
fi

# END sanity checks

# Setup input
if [[ -n "$FILE" ]]; then
  if [[ ! -f "$FILE" ]]; then
    echo "❌ File not found: $FILE"
    exit 1
  fi
  [[ "$INPLACE" == "true" ]] && cp "$FILE" "$FILE.bak"
  INPUT_STREAM="$FILE"
else
  INPUT_STREAM="/dev/stdin"
fi
# Format before processing to protect fragile regex and line-based processing
TMP_XML=$(mktemp)
xmllint --format "$INPUT_STREAM" > "$TMP_XML"
INPUT_STREAM="$TMP_XML"

source "ext_operation"

# Prepare stats
TOTAL_LINES=$(wc -l < "$TMP_XML")
TOTAL_TARGETS="${#TARGETS[@]}"
TOTAL_ITERATIONS=$(awk "BEGIN { print $TOTAL_LINES * $TOTAL_TARGETS }")
if [[ "$VERBOSE" == "true" ]]; then
  for target in "${TARGETS[@]}"; do
    echo "Target specified: ${target}"
    echo "$TOTAL_LINES total lines" >&2
    echo "$TOTAL_TARGETS total targets" >&2
    echo "$TOTAL_ITERATIONS total iterations" >&2
  done
fi

TMP_FILE="$(mktemp)"

LINE_NUM=0
ITERATION=0
WITHIN_ACTIVE=false
while IFS= read -r line || [[ -n "$line" ]]; do
  ((LINE_NUM+=1))
  [[ "$PROGRESS" == "true" && "$VERBOSE" == "false" ]] && echo -ne ">> $(awk "BEGIN { printf \"%.2f\", $ITERATION / $TOTAL_ITERATIONS * 100 }")% $ITERATION / ${TOTAL_ITERATIONS}: L#$LINE_NUM $target\r"

  new_line="$line"
  indent=$(echo "$line" | grep -o '^[[:space:]]*')

  # Track within state for --within
  if [[ -n "$WITHIN_TAG" ]]; then
    if [[ "$TARGET_MODE" == "attr" ]]; then
      if [[ "$line" =~ \<$WITHIN_TAG && ( -z "$WITHIN_TAG_ADDITIONAL" || "$line" =~ $WITHIN_TAG_ADDITIONAL ) ]]; then
        WITHIN_ACTIVE=true
      fi
    elif [[ "$TARGET_MODE" == "value" ]]; then
      if [[ "$line" =~ \<$WITHIN_TAG && ( -z "$WITHIN_TAG_ADDITIONAL" || "$line" =~ $WITHIN_TAG_ADDITIONAL )  ]]; then
        WITHIN_ACTIVE=true
      fi
      if [[ "$line" =~ \<\/$WITHIN_TAG\> ]]; then
        WITHIN_ACTIVE=false
      fi
    fi
  else
    WITHIN_ACTIVE=true
  fi

  if [[ "$WITHIN_ACTIVE" == "true" ]]; then
    for target in "${TARGETS[@]}"; do
      ((ITERATION+=1))
      pattern="$target"
      [[ "$REGEX_MODE" == "false" ]] && pattern="^$target$"

      if [[ "$TARGET_MODE" == "attr" ]]; then
        orig_line="$new_line"
        while IFS= read -r pair; do
          key=$(echo "$pair" | cut -d= -f1)
          val=$(echo "$pair" | cut -d= -f2- | tr -d '"')

          match=false
          if [[ "$REGEX_MODE" == "true" && "$key" =~ $pattern ]]; then
            match=true
          elif [[ "$REGEX_MODE" == "false" && "$key" == "$target" ]]; then
            match=true
          fi

          if [[ "$match" == "true" ]]; then
            new_val=$(apply_operation "$val" "$MODIFIER")
            orig_line=$(echo "$orig_line" | sed -E "s/($key=\")$val\"/\1$new_val\"/")
            [[ "$VERBOSE" == "true" ]] && echo "[$LINE_NUM]   Target '$target'   replaced attribute '$key' value '$val' → '$new_val'" >&2
          fi
        done < <(echo "$line" | grep -oE '[a-zA-Z0-9_.:-]+="[^"]*"')
        new_line="$orig_line"
      elif [[ "$TARGET_MODE" == "value" && "$line" =~ \<$target\>([^<]+)\</$target\> ]]; then
        old_val="${BASH_REMATCH[1]}"
        new_val=$(apply_operation "$old_val" "$MODIFIER")
        new_line=$(echo "$new_line" | sed -E "s|(<$target>)$old_val(</$target>)|\1$new_val\2|")
        [[ "$VERBOSE" == "true" ]] && echo "[$LINE_NUM]   Value modified: <$target>$old_val</$target> → <$target>$new_val</$target>" >&2
      fi
    done
  else
    ((ITERATION+="${#TARGETS[@]}"))
  fi

  if [[ "$TARGET_MODE" == "attr" && "$WITHIN_ACTIVE" == "true" && "$line" =~ \> ]]; then
    WITHIN_ACTIVE=false
  fi

  printf "%s\n" "$new_line" >> "$TMP_FILE"
done < "$INPUT_STREAM"

# Output result
if [[ "$INPLACE" == "true" ]]; then
  echo "$FILE"
  if [[ "$VERBOSE" == "true" ]]; then
    echo "Updated '$FILE' in place (backup: $FILE.bak)" >&2
  fi
else
  cat "$TMP_FILE"
  if [[ "$VERBOSE" == "true" ]]; then
    echo "Output written to stdout" >&2
  fi
fi

rm "$TMP_FILE"
rm "$TMP_XML"